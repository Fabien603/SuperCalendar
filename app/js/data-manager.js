// Gestionnaire de donn√©es pour le stockage et le chargement des donn√©es du calendrier
import { v4 as uuidv4 } from './utils/uuid.js';

export class DataManager {
    constructor() {
        // Structure de donn√©es principale
        this.data = {
            events: [],
            categories: [],
            preferences: {
                theme: 'dark',
                firstDayOfWeek: 1, // 0 = Dimanche, 1 = Lundi
                timeFormat: '24h', // '12h' ou '24h'
                notifications: 'all' // 'all', 'important', 'none'
            },
            // Version pour la compatibilit√© avec les futures mises √† jour
            version: '1.0.0',
            // Date de derni√®re modification
            lastModified: new Date().toISOString()
        };
    }
    
    // M√âTHODES DE BASE DE STOCKAGE ET CHARGEMENT
    
    // Charger les donn√©es depuis le stockage local ou Electron
    async loadData() {
        try {
            // V√©rifier si l'API Electron est disponible
            if (window.electronAPI) {
                console.log('Chargement des donn√©es depuis Electron Store');
                
                // Charger les donn√©es du calendrier
                const calendarData = await window.electronAPI.getCalendarData();
                if (calendarData && Object.keys(calendarData).length > 0) {
                    console.log('Donn√©es trouv√©es dans Electron Store');
                    
                    // V√©rifier et valider les donn√©es
                    if (this.validateImportedData(calendarData)) {
                        // Structure compatible avec la version actuelle
                        if (calendarData.events) this.data.events = calendarData.events;
                        if (calendarData.categories) this.data.categories = calendarData.categories;
                        
                        // Compatibilit√© avec les anciennes versions
                        if (calendarData.calendarData) {
                            // Ancienne structure - migration des donn√©es
                            console.log('Migration des donn√©es d\'une ancienne version');
                            if (calendarData.calendarData.events) this.data.events = calendarData.calendarData.events;
                            if (calendarData.calendarData.categories) this.data.categories = calendarData.calendarData.categories;
                        }
                    } else {
                        console.error('Structure de donn√©es incompatible - initialisation des valeurs par d√©faut');
                        this.initializeDefaultCategories();
                    }
                } else {
                    console.log('Aucune donn√©e trouv√©e - initialisation des valeurs par d√©faut');
                    this.initializeDefaultCategories();
                }
                
                // Charger les pr√©f√©rences
                const preferences = await window.electronAPI.getPreferences();
                if (preferences) {
                    this.data.preferences = { ...this.data.preferences, ...preferences };
                }
            } else {
                console.log('Chargement des donn√©es depuis le localStorage');
                
                // Fallback vers localStorage si Electron n'est pas disponible
                const savedData = localStorage.getItem('calendarAppData');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    
                    // V√©rifier et valider les donn√©es
                    if (this.validateImportedData(parsedData)) {
                        if (parsedData.events) this.data.events = parsedData.events;
                        if (parsedData.categories) this.data.categories = parsedData.categories;
                        
                        // Compatibilit√© avec les anciennes versions
                        if (parsedData.calendarData) {
                            if (parsedData.calendarData.events) this.data.events = parsedData.calendarData.events;
                            if (parsedData.calendarData.categories) this.data.categories = parsedData.calendarData.categories;
                        }
                    } else {
                        console.error('Structure de donn√©es incompatible - initialisation des valeurs par d√©faut');
                        this.initializeDefaultCategories();
                    }
                } else {
                    console.log('Aucune donn√©e trouv√©e - initialisation des valeurs par d√©faut');
                    this.initializeDefaultCategories();
                }
                
                // Charger les pr√©f√©rences
                const savedPreferences = localStorage.getItem('calendarPreferences');
                if (savedPreferences) {
                    this.data.preferences = { ...this.data.preferences, ...JSON.parse(savedPreferences) };
                }
            }
            
            // Si aucune cat√©gorie n'est d√©finie, cr√©er des cat√©gories par d√©faut
            if (this.data.categories.length === 0) {
                this.initializeDefaultCategories();
            }
            
            // S'assurer que tous les √©v√©nements r√©f√©rencent des cat√©gories valides
            this.validateEventCategories();
            
            console.log('Donn√©es charg√©es avec succ√®s:', this.data);
            return true;
        } catch (error) {
            console.error('Erreur lors du chargement des donn√©es:', error);
            // En cas d'erreur, initialiser avec des valeurs par d√©faut
            this.initializeDefaultCategories();
            throw error;
        }
    }
    
    // Sauvegarder les donn√©es dans le stockage
    async saveData() {
        try {
            // Mettre √† jour la date de derni√®re modification
            this.data.lastModified = new Date().toISOString();
            
            // Pr√©parer les donn√©es pour la sauvegarde
            const dataToSave = {
                events: this.data.events,
                categories: this.data.categories,
                version: this.data.version,
                lastModified: this.data.lastModified
            };
            
            // V√©rifier si l'API Electron est disponible
            if (window.electronAPI) {
                console.log('Sauvegarde des donn√©es dans Electron Store');
                await window.electronAPI.saveCalendarData(dataToSave);
            } else {
                console.log('Sauvegarde des donn√©es dans localStorage');
                localStorage.setItem('calendarAppData', JSON.stringify(dataToSave));
            }
            
            return true;
        } catch (error) {
            console.error('Erreur lors de la sauvegarde des donn√©es:', error);
            throw error;
        }
    }
    
    // Sauvegarder les pr√©f√©rences
    async savePreferences() {
        try {
            if (window.electronAPI) {
                await window.electronAPI.savePreferences(this.data.preferences);
            } else {
                localStorage.setItem('calendarPreferences', JSON.stringify(this.data.preferences));
            }
            return true;
        } catch (error) {
            console.error('Erreur lors de la sauvegarde des pr√©f√©rences:', error);
            throw error;
        }
    }
    
    // R√©initialiser les donn√©es
    async resetData() {
        // Conserver uniquement les cat√©gories et pr√©f√©rences
        this.data.events = [];
        
        // Mettre √† jour la date de derni√®re modification
        this.data.lastModified = new Date().toISOString();
        
        // Sauvegarder les donn√©es
        await this.saveData();
        return true;
    }
    
    // Cr√©er des cat√©gories par d√©faut
    initializeDefaultCategories() {
        this.data.categories = [
            { id: uuidv4(), name: 'Travail', color: '#2196f3', emoji: 'üíº', createdAt: new Date().toISOString() },
            { id: uuidv4(), name: 'Personnel', color: '#4caf50', emoji: 'üè†', createdAt: new Date().toISOString() },
            { id: uuidv4(), name: 'Rendez-vous', color: '#f44336', emoji: 'üîî', createdAt: new Date().toISOString() },
            { id: uuidv4(), name: 'Vacances', color: '#ff9800', emoji: 'üèùÔ∏è', createdAt: new Date().toISOString() },
            { id: uuidv4(), name: 'Sport', color: '#9c27b0', emoji: 'üèÉ', createdAt: new Date().toISOString() },
            { id: uuidv4(), name: '√âv√©nement', color: '#795548', emoji: 'üéâ', createdAt: new Date().toISOString() },
            { id: uuidv4(), name: 'Golf', color: '#4caf50', emoji: 'üèåÔ∏è', createdAt: new Date().toISOString() }
        ];
    }
    
    // M√âTHODES D'IMPORTATION ET D'EXPORTATION
    
    // Valider les donn√©es import√©es
    validateImportedData(data) {
        // V√©rifier que les donn√©es sont un objet
        if (!data || typeof data !== 'object') {
            return false;
        }
        
        // V√©rifier si les donn√©es contiennent les propri√©t√©s n√©cessaires
        // Accepter les donn√©es directes ou dans data.calendarData (compatibilit√©)
        const hasEvents = Array.isArray(data.events) || 
                         (data.calendarData && Array.isArray(data.calendarData.events));
        const hasCategories = Array.isArray(data.categories) || 
                             (data.calendarData && Array.isArray(data.calendarData.categories));
        
        return hasEvents || hasCategories;
    }
    
    // Valider les cat√©gories des √©v√©nements
    validateEventCategories() {
        // Cr√©er un ensemble des IDs de cat√©gories valides
        const validCategoryIds = new Set(this.data.categories.map(cat => cat.id));
        
        // Parcourir tous les √©v√©nements et v√©rifier/corriger leurs cat√©gories
        this.data.events.forEach(event => {
            // Si la cat√©gorie n'existe pas, la d√©finir √† null
            if (event.categoryId && !validCategoryIds.has(event.categoryId)) {
                console.warn(`Cat√©gorie invalide pour l'√©v√©nement "${event.title}" (ID: ${event.id})`);
                event.categoryId = null;
            }
        });
    }
    
    // Importer des donn√©es depuis un fichier
    async importFromFile(filePath) {
        try {
            let data;
            
            if (window.electronAPI) {
                data = await window.electronAPI.fileSystem.importCalendarFile(filePath);
            } else {
                // Pour le cas o√π nous sommes dans un navigateur sans Electron
                // Cette partie serait diff√©rente en fonction de l'API Web utilis√©e
                const fileInput = document.getElementById('import-file');
                if (!fileInput?.files?.length) {
                    throw new Error('Aucun fichier s√©lectionn√©');
                }
                
                const file = fileInput.files[0];
                const content = await file.text();
                
                if (file.name.endsWith('.json')) {
                    data = JSON.parse(content);
                } else if (file.name.endsWith('.ics')) {
                    throw new Error('Format iCal non support√© dans ce mode');
                } else {
                    throw new Error('Format de fichier non support√©');
                }
            }
            
            // V√©rifier la validit√© des donn√©es
            if (!this.validateImportedData(data)) {
                throw new Error('Format de donn√©es invalide');
            }
            
            // Mettre √† jour les donn√©es
            if (data.events) {
                this.data.events = data.events;
            } else if (data.calendarData && data.calendarData.events) {
                this.data.events = data.calendarData.events;
            }
            
            if (data.categories) {
                this.data.categories = data.categories;
            } else if (data.calendarData && data.calendarData.categories) {
                this.data.categories = data.calendarData.categories;
            }
            
            // Valider les cat√©gories des √©v√©nements
            this.validateEventCategories();
            
            // Sauvegarder les donn√©es import√©es
            await this.saveData();
            
            return true;
        } catch (error) {
            console.error('Erreur lors de l\'importation:', error);
            throw error;
        }
    }
    
    // Exporter les donn√©es vers un fichier
    async exportToFile(filePath) {
        try {
            const dataToExport = {
                events: this.data.events,
                categories: this.data.categories,
                preferences: this.data.preferences,
                exportDate: new Date().toISOString(),
                version: this.data.version
            };
            
            if (window.electronAPI) {
                const extension = filePath.toLowerCase().endsWith('.json') ? '' : '.json';
                const finalPath = filePath + extension;
                
                await window.electronAPI.fileSystem.writeFile(
                    finalPath,
                    JSON.stringify(dataToExport, null, 2),
                    { encoding: 'utf8' }
                );
            } else {
                // Pour le cas o√π nous sommes dans un navigateur sans Electron
                const dataStr = JSON.stringify(dataToExport, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                
                const link = document.createElement('a');
                link.setAttribute('href', dataUri);
                link.setAttribute('download', 'calendrier-donnees.json');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            return true;
        } catch (error) {
            console.error('Erreur lors de l\'exportation:', error);
            throw error;
        }
    }
    
    // Exporter au format iCal (√† impl√©menter ult√©rieurement)
    async exportToICS() {
        // Cette fonction serait utilis√©e pour exporter au format iCal
        throw new Error('Exportation iCal non encore impl√©ment√©e');
    }
    
    // M√âTHODES DE GESTION DES √âV√âNEMENTS
    
    // Ajouter un nouvel √©v√©nement
    addEvent(eventData) {
        // V√©rifier que les propri√©t√©s obligatoires sont pr√©sentes
        if (!eventData.title || !eventData.startDate || !eventData.endDate) {
            throw new Error('Les propri√©t√©s title, startDate et endDate sont obligatoires');
        }
        
        // G√©n√©rer un ID unique pour l'√©v√©nement
        const newEvent = {
            id: uuidv4(),
            ...eventData,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        // V√©rifier si la cat√©gorie existe si elle est sp√©cifi√©e
        if (newEvent.categoryId) {
            const categoryExists = this.data.categories.some(cat => cat.id === newEvent.categoryId);
            if (!categoryExists) {
                console.warn(`La cat√©gorie avec l'ID ${newEvent.categoryId} n'existe pas. L'√©v√©nement sera cr√©√© sans cat√©gorie.`);
                newEvent.categoryId = null;
            }
        }
        
        // Ajouter l'√©v√©nement √† la liste
        this.data.events.push(newEvent);
        
        // Sauvegarder les modifications
        this.saveData().catch(error => {
            console.error('Erreur lors de la sauvegarde apr√®s ajout d\'√©v√©nement:', error);
        });
        
        return newEvent;
    }
    
    // Mettre √† jour un √©v√©nement existant
    updateEvent(eventId, updatedData) {
        const eventIndex = this.data.events.findIndex(event => event.id === eventId);
        
        if (eventIndex === -1) {
            throw new Error('√âv√©nement non trouv√©');
        }
        
        // V√©rifier si la cat√©gorie existe si elle est sp√©cifi√©e
        if (updatedData.categoryId) {
            const categoryExists = this.data.categories.some(cat => cat.id === updatedData.categoryId);
            if (!categoryExists) {
                console.warn(`La cat√©gorie avec l'ID ${updatedData.categoryId} n'existe pas. L'√©v√©nement sera mis √† jour sans cat√©gorie.`);
                updatedData.categoryId = null;
            }
        }
        
        // Mettre √† jour l'√©v√©nement
        this.data.events[eventIndex] = {
            ...this.data.events[eventIndex],
            ...updatedData,
            updatedAt: new Date().toISOString()
        };
        
        // Sauvegarder les modifications
        this.saveData().catch(error => {
            console.error('Erreur lors de la sauvegarde apr√®s mise √† jour d\'√©v√©nement:', error);
        });
        
        return this.data.events[eventIndex];
    }
    
    // Supprimer un √©v√©nement
    deleteEvent(eventId) {
        const initialLength = this.data.events.length;
        this.data.events = this.data.events.filter(event => event.id !== eventId);
        
        if (this.data.events.length === initialLength) {
            throw new Error('√âv√©nement non trouv√©');
        }
        
        // Sauvegarder les modifications
        this.saveData().catch(error => {
            console.error('Erreur lors de la sauvegarde apr√®s suppression d\'√©v√©nement:', error);
        });
        
        return true;
    }
    
    // Supprimer tous les √©v√©nements d'une cat√©gorie
    deleteEventsByCategory(categoryId) {
        const initialLength = this.data.events.length;
        this.data.events = this.data.events.filter(event => event.categoryId !== categoryId);
        
        // Sauvegarder les modifications (m√™me si aucun √©v√©nement n'a √©t√© supprim√©)
        this.saveData().catch(error => {
            console.error('Erreur lors de la sauvegarde apr√®s suppression d\'√©v√©nements par cat√©gorie:', error);
        });
        
        return initialLength - this.data.events.length; // Retourne le nombre d'√©v√©nements supprim√©s
    }
    
    // Obtenir tous les √©v√©nements
    getAllEvents() {
        return [...this.data.events];
    }
    
    // Obtenir un √©v√©nement par ID
    getEventById(eventId) {
        const event = this.data.events.find(event => event.id === eventId);
        
        if (!event) {
            throw new Error('√âv√©nement non trouv√©');
        }
        
        return { ...event };
    }
    
    // Obtenir les √©v√©nements par jour
    getEventsByDay(date) {
        const year = date.getFullYear();
        const month = date.getMonth();
        const day = date.getDate();
        
        // Cr√©er des objets Date pour la comparaison
        const startOfDay = new Date(year, month, day, 0, 0, 0);
        const endOfDay = new Date(year, month, day, 23, 59, 59, 999);
        
        return this.data.events.filter(event => {
            const eventStartDate = new Date(event.startDate);
            const eventEndDate = new Date(event.endDate);
            
            return (
                (eventStartDate <= endOfDay && eventEndDate >= startOfDay)
            );
        });
    }
    
    // Obtenir les √©v√©nements par mois
    getEventsByMonth(year, month) {
        // Cr√©er des objets Date pour la comparaison
        const startOfMonth = new Date(year, month, 1, 0, 0, 0);
        const endOfMonth = new Date(year, month + 1, 0, 23, 59, 59, 999);
        
        return this.data.events.filter(event => {
            const eventStartDate = new Date(event.startDate);
            const eventEndDate = new Date(event.endDate);
            
            return (
                (eventStartDate <= endOfMonth && eventEndDate >= startOfMonth)
            );
        });
    }
    
    // Obtenir les √©v√©nements futurs
    getUpcomingEvents(limit = null) {
        const now = new Date();
        
        // Filtrer les √©v√©nements qui commencent maintenant ou dans le futur
        const futureEvents = this.data.events.filter(event => {
            const eventStartDate = new Date(event.startDate);
            return eventStartDate >= now;
        });
        
        // Trier par date de d√©but
        futureEvents.sort((a, b) => {
            const dateA = new Date(a.startDate);
            const dateB = new Date(b.startDate);
            return dateA - dateB;
        });
        
        // Limiter le nombre d'√©v√©nements si demand√©
        if (limit && typeof limit === 'number' && limit > 0) {
            return futureEvents.slice(0, limit);
        }
        
        return futureEvents;
    }
    
    // M√âTHODES DE GESTION DES CAT√âGORIES
    
    // Ajouter une nouvelle cat√©gorie
    addCategory(categoryData) {
        // S'assurer que les propri√©t√©s obligatoires sont pr√©sentes
        if (!categoryData.name || !categoryData.emoji || !categoryData.color) {
            throw new Error('Les propri√©t√©s name, emoji et color sont obligatoires');
        }
        
        // G√©n√©rer un ID unique
        const newId = uuidv4();
        
        const newCategory = {
            id: newId,
            ...categoryData,
            createdAt: new Date().toISOString()
        };
        
        this.data.categories.push(newCategory);
        
        // Sauvegarder les modifications
        this.saveData().catch(error => {
            console.error('Erreur lors de la sauvegarde apr√®s ajout de cat√©gorie:', error);
        });
        
        return newCategory;
    }
    
    // Mettre √† jour une cat√©gorie existante
    updateCategory(categoryId, updatedData) {
        const categoryIndex = this.data.categories.findIndex(category => category.id === categoryId);
        
        if (categoryIndex === -1) {
            throw new Error('Cat√©gorie non trouv√©e');
        }
        
        // Mettre √† jour la cat√©gorie
        this.data.categories[categoryIndex] = {
            ...this.data.categories[categoryIndex],
            ...updatedData,
            updatedAt: new Date().toISOString()
        };
        
        // Sauvegarder les modifications
        this.saveData().catch(error => {
            console.error('Erreur lors de la sauvegarde apr√®s mise √† jour de cat√©gorie:', error);
        });
        
        return this.data.categories[categoryIndex];
    }
    
    // Supprimer une cat√©gorie
    deleteCategory(categoryId) {
        const initialLength = this.data.categories.length;
        this.data.categories = this.data.categories.filter(category => category.id !== categoryId);
        
        if (this.data.categories.length === initialLength) {
            throw new Error('Cat√©gorie non trouv√©e');
        }
        
        // Mettre √† jour les √©v√©nements qui utilisaient cette cat√©gorie
        let affectedEvents = 0;
        this.data.events.forEach(event => {
            if (event.categoryId === categoryId) {
                event.categoryId = null;
                event.updatedAt = new Date().toISOString();
                affectedEvents++;
            }
        });
        
        if (affectedEvents > 0) {
            console.log(`${affectedEvents} √©v√©nement(s) modifi√©(s) suite √† la suppression de la cat√©gorie`);
        }
        
        // Sauvegarder les modifications
        this.saveData().catch(error => {
            console.error('Erreur lors de la sauvegarde apr√®s suppression de cat√©gorie:', error);
        });
        
        return true;
    }
    
    // Obtenir toutes les cat√©gories
    getAllCategories() {
        return [...this.data.categories];
    }
    
    // Obtenir une cat√©gorie par ID
    getCategoryById(categoryId) {
        if (!categoryId) return null; // Si l'ID est null ou undefined
        
        const category = this.data.categories.find(category => category.id === categoryId);
        
        if (!category) {
            console.warn(`Cat√©gorie avec ID ${categoryId} non trouv√©e, utilisation d'une valeur par d√©faut`);
            return null; // Retourner null au lieu de lancer une erreur
        }
        
        return { ...category };
    }
    
    // Obtenir les √©v√©nements par cat√©gorie
    getEventsByCategory(categoryId) {
        return this.data.events.filter(event => event.categoryId === categoryId);
    }
    
    // M√âTHODES DE GESTION DES PR√âF√âRENCES
    
    // Obtenir toutes les pr√©f√©rences
    getPreferences() {
        return { ...this.data.preferences };
    }
    
    // Mettre √† jour les pr√©f√©rences
    updatePreferences(newPreferences) {
        this.data.preferences = {
            ...this.data.preferences,
            ...newPreferences
        };
        
        // Sauvegarder les pr√©f√©rences
        this.savePreferences().catch(error => {
            console.error('Erreur lors de la sauvegarde des pr√©f√©rences:', error);
        });
        
        return this.data.preferences;
    }
}